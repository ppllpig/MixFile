name: Sync, Patch, Build and Release

on:
  schedule:
    # 每天 UTC 时间 0 点触发 (北京时间早上8点)
    - cron: '0 0 * * *'
  workflow_dispatch: # 允许手动触发

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    # 步骤 1: 检出您自己的仓库
    - name: Checkout your repository
      uses: actions/checkout@v4

    # 步骤 2: 设置 Git 用户信息
    - name: Set up Git user
      run: |
        git config --global user.name 'github-actions[bot]'
        git config --global user.email 'github-actions[bot]@users.noreply.github.com'

    # 步骤 3: 同步上游最新代码
    - name: Sync with Upstream Latest
      run: |
        git remote add upstream https://github.com/InvertGeek/MixFile.git
        git fetch upstream master
        git reset --hard upstream/master

    # 步骤 4: 注入修改后的代码
    - name: Inject Modified Code
      run: |
        MOD_DIR="app/src/main/java/com/donut/mixfile/ui/routes/webdav"
        
        # 注入 Dialogs.kt
        cat > "${MOD_DIR}/Dialogs.kt" << 'EOF'
        package com.donut.mixfile.ui.routes.webdav

        import android.content.Context
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.foundation.layout.fillMaxWidth
        import androidx.compose.material3.CircularProgressIndicator
        import androidx.compose.material3.OutlinedTextField
        import androidx.compose.material3.Text
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.platform.LocalContext
        import androidx.compose.ui.text.style.TextOverflow
        import androidx.compose.ui.unit.dp
        import com.donut.mixfile.kv
        import com.donut.mixfile.server.WEB_DAV_KEY
        import com.donut.mixfile.server.core.objects.WebDavFile
        import com.donut.mixfile.server.core.routes.api.webdav.objects.WebDavManager
        import com.donut.mixfile.server.core.utils.resolveMixShareInfo
        import com.donut.mixfile.server.mixFileServer
        import com.donut.mixfile.ui.component.common.MixDialogBuilder
        import com.donut.mixfile.ui.theme.colorScheme
        import com.donut.mixfile.util.AsyncEffect
        import com.donut.mixfile.util.errorDialog
        import com.donut.mixfile.util.file.doUploadFile
        import com.donut.mixfile.util.file.downloadUrl
        import com.donut.mixfile.util.file.loadDataWithMaxSize
        import com.donut.mixfile.util.file.loadFileList
        import com.donut.mixfile.util.formatFileSize
        import com.donut.mixfile.util.getCurrentTime
        import com.donut.mixfile.util.objects.ProgressContent
        import com.donut.mixfile.util.showToast
        import kotlinx.coroutines.Dispatchers
        import kotlinx.coroutines.withContext
        import java.io.File

        fun clearWebDavData() {
            MixDialogBuilder("确定清空webdav数据?").apply {
                var text by mutableStateOf("")
                setContent {
                    OutlinedTextField(
                        value = text,
                        onValueChange = {
                            text = it
                        },
                        modifier = Modifier.fillMaxWidth(),
                        label = {
                            Text(text = "请输入确认")
                        },
                        maxLines = 1,

                        )
                }
                setDefaultNegative()
                setPositiveButton("确认") {
                    if (!text.contentEquals("确认")) {
                        showToast("请输入确认")
                        return@setPositiveButton
                    }
                    mixFileServer.webDav.WEBDAV_DATA.files.clear()
                    kv.remove(WEB_DAV_KEY)
                    showToast("数据已清空")
                    closeDialog()
                }
                show()
            }
        }

        fun exportWebDavData() {
            MixDialogBuilder("确定导出?").apply {
                var fileName by mutableStateOf("webdav存档-${getCurrentTime()}")
                setContent {
                    Column(
                        modifier = Modifier.fillMaxWidth(),
                        verticalArrangement = Arrangement.spacedBy(5.dp)
                    ) {
                        OutlinedTextField(
                            value = fileName,
                            onValueChange = {
                                fileName = it
                            },
                            modifier = Modifier.fillMaxWidth(),
                            label = {
                                Text(text = "存档备注")
                            },
                            maxLines = 1,
                        )
                        Text(text = "将会导出当前webdav存档")
                    }
                }
                setDefaultNegative()
                setPositiveButton("确定") {
                    val data = mixFileServer.webDav.dataToBytes()
                    val finalFileName = "${fileName}.mix_dav".substringAfterLast('/') // Ensure only filename is used
                    doUploadFile(
                        data,
                        finalFileName,
                        false
                    )
                    closeDialog()
                }
                show()
            }
        }


        fun importFileListToWebDav(url: String) {
            val progress = ProgressContent()
            MixDialogBuilder("解析中").apply {
                setContent {
                    AsyncEffect {
                        errorDialog("解析文件失败", onError = { closeDialog() }) {
                            val dav = mixFileServer.webDav
                            val fileList = loadFileList(url, progress)
                            dav.importMixList(fileList)
                            dav.saveData()
                            showToast("导入完成")
                            withContext(Dispatchers.Main) {
                                closeDialog()
                            }
                        }
                    }
                    progress.LoadingContent()
                }
                setDefaultNegative()
                show()
            }

        }

        fun tryImportWebDavData(code: String) {
            val shareInfo = resolveMixShareInfo(code)
            if (shareInfo == null) {
                showToast("解析分享码失败")
                return
            }
            val url = shareInfo.toDataLog().downloadUrl
            if (shareInfo.fileName.endsWith(".mix_list")) {
                MixDialogBuilder("确定导入文件列表?").apply {
                    setContent {
                        Column(modifier = Modifier.fillMaxWidth()) {
                            Text(
                                "文件列表: ${shareInfo.fileName}",
                                color = colorScheme.primary,
                                maxLines = 1,
                                overflow = TextOverflow.Ellipsis
                            )
                            Text("大小: ${formatFileSize(shareInfo.fileSize)}", color = colorScheme.primary)
                        }
                    }
                    setPositiveButton("确定") {
                        closeDialog()
                        importFileListToWebDav(url)
                    }
                    setDefaultNegative()
                    show()
                }
                return
            }
            if (!shareInfo.fileName.endsWith(".mix_dav")) {
                showToast("错误的文件格式")
                return
            }
            MixDialogBuilder("确定导入存档?").apply {
                setContent {
                    Column(modifier = Modifier.fillMaxWidth()) {
                        Text(
                            "存档: ${shareInfo.fileName}",
                            color = colorScheme.primary,
                            maxLines = 1,
                            overflow = TextOverflow.Ellipsis
                        )
                        Text("大小: ${formatFileSize(shareInfo.fileSize)}", color = colorScheme.primary)
                    }
                }
                setPositiveButton("确定") {
                    closeDialog()
                    importWebDavData(url)
                }
                setDefaultNegative()
                show()
            }
        }

        suspend fun importWebDavData(data: WebDavFile) {
            val dav = mixFileServer.webDav
            data.files.forEach {
                dav.WEBDAV_DATA.addFile(it.value)
            }
            dav.saveData()
        }

        fun importWebDavData(manager: WebDavManager) {
            MixDialogBuilder(
                "导入中",
                autoClose = false
            ).apply {
                setContent {
                    AsyncEffect {
                        importWebDavData(manager.WEBDAV_DATA)
                        showToast("导入成功")
                        closeDialog()
                    }
                    Column(
                        modifier = Modifier.fillMaxSize(),
                        verticalArrangement = Arrangement.Center,
                        horizontalAlignment = Alignment.CenterHorizontally
                    ) {
                        CircularProgressIndicator()
                    }
                }
                show()
            }
        }

        fun importWebDavData(url: String) {
            val progress = ProgressContent()
            MixDialogBuilder("导入中").apply {
                setContent {
                    AsyncEffect {
                        errorDialog("导入失败", onError = { closeDialog() }) {
                            val webDavData = loadDataWithMaxSize(url, progress)
                            val dav = mixFileServer.webDav
                            val data = dav.parseDataFromBytes(webDavData)
                            importWebDavData(data)
                            showToast("导入成功!")
                        }
                        withContext(Dispatchers.Main) {
                            closeDialog()
                        }
                    }
                    progress.LoadingContent()
                }
                setDefaultNegative()
                show()
            }
        }

        fun downloadToWebDav(url: String) {
            val progress = ProgressContent()
            MixDialogBuilder("下载并导入中").apply {
                setContent {
                    // 修复 #1: 通过 LocalContext.current 获取 Context
                    val context = LocalContext.current
                    AsyncEffect {
                        errorDialog("下载失败", onError = { closeDialog() }) {
                            val data = loadDataWithMaxSize(url, progress)
                            val dav = mixFileServer.webDav
                            val fileName = url.substringAfterLast("/")
                            
                            val tempDir = File(context.cacheDir, "webtemp")
                            if (!tempDir.exists()) {
                                tempDir.mkdirs()
                            }
                            val tempFile = File(tempDir, fileName)
                            tempFile.writeBytes(data)

                            // 修复 #2: 传入文件路径字符串，而不是 File 对象
                            val newFile = WebDavFile(tempFile.name)
                            dav.WEBDAV_DATA.addFile(newFile)
                            dav.saveData()
                            
                            tempFile.delete()
                            
                            showToast("下载并导入成功!")
                        }
                        withContext(Dispatchers.Main) {
                            closeDialog()
                        }
                    }
                    progress.LoadingContent()
                }
                setDefaultNegative()
                show()
            }
        }
        EOF

        # 注入 WebDav.kt
        cat > "${MOD_DIR}/WebDav.kt" << 'EOF'
        package com.donut.mixfile.ui.routes.webdav

        import androidx.compose.foundation.ExperimentalFoundationApi
        import androidx.compose.foundation.clickable
        import androidx.compose.foundation.interaction.MutableInteractionSource
        import androidx.compose.foundation.layout.ExperimentalLayoutApi
        import androidx.compose.foundation.layout.Row
        import androidx.compose.foundation.layout.fillMaxWidth
        import androidx.compose.foundation.layout.padding
        import androidx.compose.material.icons.Icons
        import androidx.compose.material.icons.outlined.Close
        import androidx.compose.material3.Button
        import androidx.compose.material3.Icon
        import androidx.compose.material3.OutlinedButton
        import androidx.compose.material3.OutlinedTextField
        import androidx.compose.material3.Text
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.unit.dp
        import com.donut.mixfile.ui.nav.MixNavPage
        import com.donut.mixfile.ui.routes.UploadDialogCard
        import com.donut.mixfile.ui.routes.home.serverAddress
        import com.donut.mixfile.ui.theme.colorScheme
        import com.donut.mixfile.util.copyToClipboard
        import com.donut.mixfile.util.readClipBoardText

        @OptIn(ExperimentalLayoutApi::class, ExperimentalFoundationApi::class)
        val WebDAV = MixNavPage(
            gap = 10.dp,
            horizontalAlignment = Alignment.CenterHorizontally,
        ) {
            var text by remember {
                mutableStateOf("")
            }
            val webDavAddress = "$serverAddress/api/webdav"
            Text(
                text = "WebDAV局域网连接地址: $webDavAddress",
                color = colorScheme.primary,
                modifier = Modifier.clickable {
                    webDavAddress.copyToClipboard()
                })
            UploadDialogCard()
            Button(onClick = {
                exportWebDavData()
            }, modifier = Modifier.fillMaxWidth()) {
                Text("导出文件")
            }
            OutlinedButton(onClick = {
                clearWebDavData()
            }, modifier = Modifier.fillMaxWidth()) {
                Text("清空文件")
            }
            OutlinedTextField(
                value = text,
                onValueChange = {
                    text = it
                },
                modifier = Modifier.fillMaxWidth(), label = {
                    Text(text = "请输入分享码")
                },
                maxLines = 3,
                trailingIcon = {
                    if (text.isNotEmpty()) {
                        Icon(
                            Icons.Outlined.Close,
                            tint = colorScheme.primary,
                            contentDescription = "clear",

                            modifier = Modifier.clickable(
                                indication = null,
                                interactionSource = remember { MutableInteractionSource() }) {
                                text = ""
                            })
                    }
                }
            )

            Text("支持webdav存档文件和mix_list文件导入", color = colorScheme.primary)

            Row {
                OutlinedButton(
                    onClick = { text = readClipBoardText() },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("粘贴内容")
                }
                Button(
                    onClick = { tryImportWebDavData(text) },
                    modifier = Modifier.weight(1f).padding(start = 10.dp)
                ) {
                    Text("导入文件")
                }
            }

            var downloadUrl by remember { mutableStateOf("") }
            OutlinedTextField(
                value = downloadUrl,
                onValueChange = { downloadUrl = it },
                label = { Text("请输入下载链接") },
                modifier = Modifier.fillMaxWidth()
            )
            Button(
                onClick = {
                    if (downloadUrl.isNotEmpty()) {
                        downloadToWebDav(downloadUrl)
                    }
                },
                modifier = Modifier.fillMaxWidth()
            ) {
                Text("下载到 WebDAV")
            }

        }
        EOF

    # 步骤 5: 设置构建环境
    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'
        distribution: 'temurin'
    - name: Setup Gradle
      uses: gradle/gradle-build-action@v2
    - name: Grant execute permission for gradlew
      run: chmod +x gradlew

    # 步骤 6: 构建 APK
    - name: Build with Gradle
      run: ./gradlew assembleRelease

    # 步骤 7: 提取版本号并创建/更新 Release
    - name: Create or Update Release
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        VERSION_NAME=$(grep "versionName =" app/build.gradle.kts | sed 's/.*versionName = "\(.*\)"/\1/')
        gh release create "v$VERSION_NAME-mod" app/build/outputs/apk/release/*.apk --repo ${{ github.repository }} --title "v$VERSION_NAME (Patched)" --notes "Automated build with WebDAV download feature." || gh release upload "v$VERSION_NAME-mod" app/build/outputs/apk/release/*.apk --repo ${{ github.repository }} --clobber